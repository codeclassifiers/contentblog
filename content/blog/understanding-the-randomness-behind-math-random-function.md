---
path: maths-randon-in-javascript
date: 2020-07-13T15:53:56.371Z
title: Understanding the randomness behind Math.random() function
description: Let understand the underlying implementation of Math.random() function
---
* Introduction
  * If you are a web developer then l I am pretty sure you must have used or come across **Math.random()** in JavaScript at least once. Most of us know that it gives us back a Pseudo-Random Number viz. a number which might seem random but at some level is deterministic based on the function used.
* Research
  * So the first article which I came across about about this function was from v8 engine's blog on [implementation of Math.random()](https://v8.dev/blog/math-random) which goes into detail about the algorithms used to generate random number in v8 engine which is mainly used by chrome browser.
* Deep Dive
      - Now the interesting thing to realise here Javascript language does not have a specific implementation of this function. There are broad specs specified based on which each browser can have thier own implementation for generating random numbers.
      - Most of the browsers used to have some variation of popular pseudo-random number generation algorithms in their internal engines. In 2015 all the browsers shifted from older algorithms to a standard algorithm called **xorshift128+**(Yeah adding + at the end definitely makes it looks cool).
      - If we go through the actual c implmentation of the algorithm it looks like this:
  * ```c
    uint64_t state0 = 1;
    uint64_t state1 = 2;
    uint64_t xorshift128plus() {
      uint64_t s1 = state0;
      uint64_t s0 = state1;
      state0 = s0;
      s1 ^= s1 << 23;
      s1 ^= s1 >> 17;
      s1 ^= s0;
      s1 ^= s0 >> 26;
      state1 = s1;
      return state0 + state1;
    }
    ```
* Now as a web developer it might seem a bit daunting task to understand this algorithm in C language so let's port the same implementation to Javascript and understand it better: 
* ```javascript
  // Javascript implementation of xorshift128+
  let state0 = 1; // SEED 
  let state1 = 2; // SEED
  function xorshift() {
      let s1 = state0; 
      let s0 = state1; 
      state0 = s0; 
      s1 ^= s1 << 23;  // SHIFT
      s1 ^= s1 >> 17;  // SHIFT
      s1 ^= s0;
      s1 ^= s0 >> 26;  // SHIFT
      state1 = s1;
      return state0 + state1;
  }
  console.log(xorshift());
  ```
* The above code looks a bit better but still needs a bit more explanation so let's deep dive into it step by step...
* The first two lines of the algorithm are pretty simple to understand. We initialise two seed values `state0` and `state1`.
* Next from line 4, the real implementation of our algorithm starts. On line 5 and 6 we copy the values of our seed values into variables `s1` and `s0` for temporary manipulations. Next, on line 7 we copy the value of `s0` into `state0` variables. At this point if we log the values of all variables they will be:
  `state0=2, state1=2, s0=2, s1= 1` 
* Now we come to the most important part of the algorithm...
  `Line 8: s1 ^= s1 << 23;  // SHIFT`
* Here first we are performing left shift operation on variable s1 with the syntax `s1 << 23` where the binary equivalent of s1 input value is `1` is left-shifted by 23 places. Here is visual representation of how that operation is performed internally:
  ![Left shift](https://res.cloudinary.com/dk22rcdch/image/upload/v1594474288/Blogimages/Screenshot_2020-07-11_at_7.01.11_PM_shh38t.png "Left shift step")
* Next, we perform xor operation on this value with \`s1\` variable by using \`^=\` syntax. XOR operation compares the binary representations of two numbers and outputs 0 where corresponding bits match and outputs 1 where corresponding bits are different. The XOR operation of s1(of value 1) with the output from previous operation(8388608) is as follows:
  ![XOR shift](https://res.cloudinary.com/dk22rcdch/image/upload/v1594475093/Blogimages/Screenshot_2020-07-11_at_7.13.23_PM_ipjkjb.png "XOR shift")
- In the next 4 lines, similar XOR and shifting operations occur and at line 13 we return the sum values `state1` and `state2`. One important thing to keep in mind is that it is the initial seed values which are actually changing to generate the random values.
- The numbers generated by xorshift128+ aren’t actually random, they’re only relatively evenly distributed over the expected range of values. 
- Now how the seed values are selected is dependant on the browsers and underlying engine implementations based on which the range of random values differ.
- **Conclusion**
    - In a nutshell, all the algorithm is really doing here is taking some input, doing some binary operations on them, and giving us a random number. Although the output is quite predictable over long terms but seems pretty random for our day to day use cases. 
- References :   
    - The concept was originally covered by:
Daniel Simmons on [Hackernoon Blog](https://hackernoon.com/how-does-javascripts-math-random-generate-random-numbers-ef0de6a20131)
